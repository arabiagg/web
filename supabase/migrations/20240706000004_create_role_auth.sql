CREATE TYPE "public"."arabia_role" AS ENUM (
    'tournament_host',
    'admin'
);

CREATE TYPE "public"."arabia_permission" AS ENUM (
    'tournament.create', 'tournament.update', 'tournament.delete',
    'match.create', 'match.update', 'match.delete'
);

CREATE TABLE IF NOT EXISTS "public"."user_roles" (
    "id" bigint NOT NULL,
    "user_id" "uuid" NOT NULL,
    "role" "public"."arabia_role" NOT NULL
);

CREATE TABLE IF NOT EXISTS "public"."role_permissions" (
    "role" "public"."arabia_role" NOT NULL,
    "permission" "public"."arabia_permission" NOT NULL,
    UNIQUE ("role", "permission")
);


ALTER TABLE ONLY "public"."user_roles"
    ADD CONSTRAINT "user_roles_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."user_roles"
    ADD CONSTRAINT "user_roles_user_id_role_key" UNIQUE ("user_id", "role");

ALTER TABLE ONLY "public"."user_roles"
    ADD CONSTRAINT "user_roles_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;

ALTER TABLE "public"."user_roles" ALTER COLUMN "id" ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME "public"."user_roles_id_seq"
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);

CREATE OR REPLACE FUNCTION "public"."custom_access_token_hook"("event" "jsonb") RETURNS "jsonb"
    LANGUAGE "plpgsql" STABLE
    AS
$$
  declare
    claims jsonb;
    user_role public.arabia_role;
  begin
    -- Fetch the user role in the user_roles table
    select role into user_role from public.user_roles where user_id = (event->>'user_id')::uuid;

    claims := event->'claims';

    if user_role is not null then
      -- Set the claim
      claims := jsonb_set(claims, '{user_role}', to_jsonb(user_role));
    else
      claims := jsonb_set(claims, '{user_role}', 'null');
    end if;

    -- Update the 'claims' object in the original event
    event := jsonb_set(event, '{claims}', claims);

    -- Return the modified or original event
    return event;
  end;
$$;


CREATE OR REPLACE FUNCTION public.authorize(
    requested_permission arabia_permission
)
    returns boolean as $$
declare
    bind_permissions int;
    user_role public.arabia_role;
begin
    -- Fetch user role once and store it to reduce number of calls
    select (auth.jwt() ->> 'user_role')::public.arabia_role into user_role;

    IF user_role = 'admin' THEN
        RETURN True;
    END IF;

    select count(*) into bind_permissions
        from public.role_permissions
        where role_permissions.permission = requested_permission and role_permissions.role = user_role
    ;

    return bind_permissions > 0;
end;
$$ language plpgsql stable security definer set search_path = '';
